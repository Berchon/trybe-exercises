# Exerc√≠cios
Nos exerc√≠cios iremos utilizar diversos conceitos que aprendemos at√© aqui, praticando como √© pensar de uma maneira diferente, agora que sabemos um pouco mais sobre os computadores e como eles funcionam.

**Exerc√≠cio 1:** Crie um projeto que ir√° simular a arquitetura que vimos em aula de uma maneira bem simples, ela ter√° um arquivo principal para a execu√ß√£o do programa que representar√° nosso Sistema Operacional e duas classes que representar√£o a Mem√≥ria Principal e a Secund√°ria .
Cada tipo de mem√≥ria ir√° armazenar os dados de fato na mem√≥ria que ela representa, sendo a Principal armazenando tudo em mem√≥ria RAM e a secund√°ria no disco atrav√©s do fs (File System) e atrav√©s do NodeJS estaremos fazendo chamadas ao Sistema Operacional para realizar essas tarefas para gente, pois ele melhor do que ningu√©m saber√° utilizar as mem√≥rias. O objetivo do nosso script ser√° realizar a soma de um array de n√∫meros aleat√≥rios utilizando as duas implementa√ß√µes de mem√≥ria. Os dados ser√£o sempre armazenados como strings!

Vamos l√°:
1. Crie um novo diret√≥rio na sua m√°quina para os exerc√≠cios (pode chamar ele de computador ou pc üòé), os pr√≥ximos arquivos dever√£o ser criados dentro dela.
2. Vamos come√ßar a nossa mem√≥ria principal, ou mem√≥ria RAM, para isso crie um arquivo MainMemory.js e adicione o conte√∫do abaixo nela. Implemente os m√©todos get e load .
    * No get voc√™ ir√° retornar a posi√ß√£o dada ( index ) do array de loadedMemory . N√£o esque√ßa de converter o valor para num√©rico ( float ou int ).
    * No load voc√™ ir√° adicionar ( push ) o elemento passado ( value ) ao array loadedMemory .
```javascript
    class MainMemory {
      constructor () {
        this.loadedMemory = []
      }

      load (value) {
        //
      }

      get (index) {
        //
      }

      clean () {
        this.loadedMemory = []
      }
    }

    module.exports = MainMemory
```

*Perceba que ela de fato ela estar√° armazenando os valores na mem√≥ria RAM, atrav√©s das vari√°veis que definimos!*

3. Agora, crie um arquivo SecondaryMemory.js para ser a nossa mem√≥ria secund√°ria e adicione o conte√∫do abaixo. Mais uma vez voc√™ ser√° respons√°vel pela implementa√ß√£o dos m√©todos get e load por√©m, agora, utilizaremos o fs , para persistir esses dados em disco.
    * No load , utilizando o m√©todo writeFileSync do fs , escreva o c√≥digo que crie um novo arquivo utilizando nextFileName como path e salve o value no conte√∫do deste novo arquivo.
    * No get , retorne o conte√∫do do arquivo fileName , utilize o m√©todo readFileSync do fs . N√£o esque√ßa de converter o valor para num√©rico ( float ou int ).
    * Crie, no diret√≥rio de onde estiver executando os programas, um diret√≥rio disk para guardar os dados que voc√™ salvar√° em disco.
```javascript
    const fs = require('fs')

    const DISK_PATH = './disk'

    class SecondaryMemory {
      load (value) {
        const disk = fs.readdirSync(DISK_PATH)

        const nextFileName = `${DISK_PATH}/cel${disk.length}`

        //
      }

      get (index) {
        const fileName = `${DISK_PATH}/cel${index}`

        //
      }

      clean () {
        fs.rmdirSync(DISK_PATH, { recursive: true })
        fs.mkdirSync(DISK_PATH)
      }
    }

    module.exports = SecondaryMemory
```
4. Vamos criar nosso arquivo principal para gerenciar as "mem√≥rias" que criamos, crie um novo arquivo operatingSystem.js e coloque o seguinte conte√∫do:
```javascript
    const SecondaryMemory = require('./SecondaryMemory')
    const MainMemory = require('./MainMemory')

    const secondaryMemory = new SecondaryMemory()
    const mainMemory = new MainMemory()

    // Conjunto de n√∫meros aleat√≥rios a serem somados
    const randomNumbers = [
      '36912',
      '84300'
    ]

    // Carregando todos os n√∫meros em mem√≥ria (principal e secund√°ria)
    randomNumbers.forEach((number) => {
      secondaryMemory.load(number)
      mainMemory.load(number)
    })

    // Interando sobre os n√∫meros carregados na MEMORIA PRINCIPAL e realizando a soma
    let initialMainMemoryTime = Date.now()
    let mainMemorySum = 0
    for (let i = 0; i < randomNumbers.length; i++) {
      mainMemorySum += mainMemory.get(i)
    }
    console.log(`Mem√≥ria Principal\nSoma: ${mainMemorySum} Tempo gasto: ${Date.now() - initialMainMemoryTime}ms\n`)

    // Interando sobre os n√∫meros carregados na MEMORIA SECUNDARIA e realizando a soma
    let initialSecondaryMemoryTime = Date.now()
    let secondaryMemorySum = 0
    for (let i = 0; i < randomNumbers.length; i++) {
      secondaryMemorySum += secondaryMemory.get(i)
    }
    console.log(`Mem√≥ria Secund√°ria\nSoma: ${secondaryMemorySum} Tempo gasto: ${Date.now() - initialSecondaryMemoryTime}ms`)
```
*Perceba que o script do nosso Sistema Operacional faz duas coisas: primeiro carrega os valores do array `randomNumbers` para a devida mem√≥ria utilizando o m√©todo `load` de cada classe, ent√£o, ele roda um la√ßo de repeti√ß√£o, pelo `length` do array, buscando cada valor na mem√≥ria utilizando o m√©todo `get` de cada uma. Por fim, ele imprime no console o tempo e o valor da soma dos n√∫meros para cada loop, ou seja, o resultado da opera√ß√£o com cada tipo de mem√≥ria.*

5. Vamos testar nosso script, execute o arquivo operatingSystem.js e veja a sa√≠da no console. Deu certo?! Como foram os tempos de sa√≠da?!
6. Para deixar nosso script ainda mais legal, vamos aumentar a quantidade de n√∫meros para serem somados, adicione uma grande quantidade de n√∫meros no array de n√∫meros aleat√≥rios (bastante mesmo, tipo uns 200). E rode o script novamente. Como foi o tempo de resposta agora? deu diferen√ßa? qual foi mais r√°pido?!
7. Agora, vamos refor√ßar mais um conte√∫do apreendido, comente o trecho do c√≥digo que carrega os n√∫meros da mem√≥ria e execute novamente. Compare os resultados das somas. O que aconteceu?
1. 
**Exerc√≠cio 2:** Agora vamos explorar o papel do sistema operacional e o gerenciamento de recursos, para isso utilizaremos os m√≥dulos nativos do NodeJS, para solicitar chamadas do SO que nos mostre informa√ß√µes dos recursos de nossa m√°quina. Crie um script chamado resources.js e utilize-o para exibir no console as seguintes informa√ß√µes:
1. A plataforma que estamos utilizando, por exemplo: linux, win32, darwin, etc., a arquitetura, por exemplo, x32 ou x64 , e a vers√£o (release). Para isso utilize o m√≥dulo os do NodeJS
2. Adicione o c√≥digo para exibir a quantidade de cores da sua CPU e o modelo e a velocidade em gigahertz - GHz de cada um (utilize o valor vindo em speed e fa√ßa a convers√£o üòé).
3. Exiba tamb√©m a quantidade total de mem√≥ria RAM dispon√≠vel em sua m√°quina em gigabytes - GB (fa√ßa a convers√£o tamb√©m üòâ).
1. 
**Exerc√≠cio 3:** Fa√ßa um script que, a cada intervalo de segundo, mostre no console a mem√≥ria utilizada do sistema operacional vs a mem√≥ria total (ambos em megabytes).

**Exerc√≠cio 4:** Fa√ßa um script que exibe o seu respectivo process id utilizando o m√≥dulo process do NodeJS e ent√£o fique em execu√ß√£o por um determinado tempo. Agora utilizando os comandos de monitoramento visto no conte√∫do, exiba os processos em execu√ß√£o e ent√£o identifique o seu processo.
